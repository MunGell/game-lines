/* DOM objects */
function ID(id) {
    return document.getElementById(id);
};

function Class(className) {
    return document.getElementsByClassName(className)[0];
}

function getNodesOf(obj, str) {
    if (str) var tags = str.toHash();
    var result = [], items = obj.childNodes;
    for (var i = 0, lim = items.length; i < lim; i++) {
        var item = items[i];
        if (item.nodeType != 1) continue;
        if (!tags || tags[item.tagName]) result.push(item);
    }
    return result;
};

function getPositionOf(obj) {
    var pos = {x: 0, y: 0};
    for (var p = obj; p; p = p.offsetParent) {
        pos.x += p.offsetLeft;
        pos.y += p.offsetTop;
    }
    return pos;
};

function makeVisible(obj) {
    obj.style.visibility = 'visible';
};
function makeHidden(obj) {
    obj.style.visibility = 'hidden';
};

/* Events */
function processEvent(obj, method) {
    var args = [].splice.call(arguments, 2);
    return function (event) {
        event = event || window.event;
        obj[method].apply(obj, [event].concat(args));
    };
};
function stopEvent(event) {
    event = event || window.event;
    event.cancelBubble = true;
};

/* className editor */
function classNameOf(obj) {
    var cne = classNameEditor;
    cne.value = obj.className;
    cne.obj = obj;
    return cne;
};

var classNameEditor = {
    seek: function (str) {
        var s = ' ', spaced = s + this.value + s;
        return spaced.seek(s = str + s);
    },
    add: function (str) {
        if (!this.value.seek(str))
            this.obj.className = this.value + ' ' + str;
    },
    remove: function (str) {
        if (!this.value.seek(str)) return;
        var s = ' ', spaced = s + this.value + s;
        var sample = new RegExp(s + str + s);
        this.obj.className = spaced.replace(sample, s).trim();
    },
    flip: function (str) {
        var newValue = this.add(str);
        if (this.value == newValue) this.remove(str);
    }
};

/* Prototypes */
String.prototype.seek = function (str) {
    return (this.indexOf(str) > -1);
};

String.prototype.toHash = function (spacer) {
    var s = spacer || ' ', hash = {};
    var a = this.split(s), i = a.length;
    while (i-- > 0) hash[a[i]] = true;
    return hash;
};
String.prototype.trim = function () {
    return this.replace(/^\s+|\s+$/g, '');
};

Number.prototype.decline = function (word) {
    var n = this + ' ', p = word.split(/- |,/g);
    var pn = n.match(/([^1]|^)1 /) ? 1 : (n.match(/([^1]|^)[234] /) ? 2 : 3);
    return n + p[0] + p[pn];
};

/* Grid */
var linesGrid = {
    checkSquares: [],
    init: function () {
        if (!this.ready) {
            this.obj = Class('grid');
            this.squares = [];
        }
        this.unselect();
        for (x = 0; x < 9; x++) {
            if (!this.ready) {
                this.squares[x] = [];
            }
            for (y = 0; y < 9; y++) {
                if (this.ready) {
                    this.squares[x][y].deleteBall();
                } else {
                    this.squares[x][y] = new Square(x, y);
                }
            }
        }
        Preview.init();
        Score.init();
        if (this.ready) {
            Cookies.expire('savedgame');
        }
        this.ready = true;
        this.loadGame();
    },
    reset: function () {
        for (x = 0; x < 9; x++) {
            for (y = 0; y < 9; y++) {
                var item = this.squares[x][y];
                item.step = null;
                item.from = null;
            }
        }
        pathfinder.init();
    },
    unselect: function () {
        if (this.selected) {
            classNameOf(this.selected.obj).remove('selected');
            this.selected = null;
        }
    },
    add: function () {
        var empty = [];
        for (x = 0; x < 9; x++) {
            for (y = 0; y < 9; y++) {
                var item = this.squares[x][y];
                if (!item.ball) {
                    empty.push(item);
                }
            }
        }
        if (empty.length) {
            var n = Math.floor(Math.random() * empty.length - 0, 01);
            empty[n].createBall(Preview.use());
            this.checkSquares.push(empty[n]);
        }
    },
    turn: function () {
        for (var i = 0; i < 3; i++) {
            this.add();
        }
        this.makeTurn = false;
        animation.onfinish = 'linesGrid.checkLines()';
        animation.start();
    },
    checkLines: function () {
        var item = this.checkSquares.shift();
        if (item && item.ball) {
            var same = item.findSame();
            if (same.items.length > 4) {
                same.fire();
            } else {
                this.checkLines();
            }
        } else if (this.makeTurn) {
            this.turn();
        } else {
            if (this.selected) {
                this.selected.select();
            }
            this.saveGame();
        }
    },
    saveGame: function () {
        var balls = [];
        for (x = 0; x < 9; x++) {
            for (y = 0; y < 9; y++) {
                var item = this.squares[x][y].ball;
                if (item) {
                    var coords = x.toString() + y.toString();
                    balls.push(coords + item.color);
                }
            }
        }
        if (balls.length < 81) {
            var saved = balls.join('-') + '~' + Preview.items.join('-') + '~' + Score.value;
            Cookies.set('savedgame', saved);
        } else {
            Cookies.expire('savedgame');
            alert('Game over');
        }
    },
    loadGame: function () {
        var summary = Cookies.get('savedgame');
        if (summary) {
            var values = summary.split('~');
            var balls = values[0].split('-');
            for (var i = 0, lim = balls.length; i < lim; i++) {
                var str = balls[i];
                var x = parseInt(str.charAt(0));
                var y = parseInt(str.charAt(1));
                this.squares[x][y].createBall(str.substr(2));
            }
            Preview.items = values[1].split('-');
            Preview.update();
            Score.value = parseInt(values[2]);
            Score.obj.innerHTML = Score.value;
            this.makeTurn = false;
            animation.start();
        } else {
            this.makeTurn = true;
            this.turn();
        }
        highscore.init();
    }
};

/* Colors for next turn */
var Preview = {
    colors: ['yellow', 'green', 'red', 'blue', 'violet', 'aqua', 'pink'],
    init: function () {
        var list = Class('preview');
        this.nodes = getNodesOf(list);
        this.items = [];
        for (var i = 0; i < 3; i++) {
            this.add();
        }
        this.update();
    },
    add: function () {
        var c = Math.floor(Math.random() * this.colors.length);
        this.items.push(this.colors[c]);
    },
    use: function () {
        var color = this.items.shift();
        this.add();
        this.update();
        return color;
    },
    update: function () {
        for (var i = 0; i < 3; i++) {
            this.nodes[i].className = 'ball ball-' + this.items[i];
        }
    }
};

/* Find path for a ball */
var pathfinder = {
    init: function () {
        this.items = [];
        this.size = 0;
    },
    add: function (item) {
        this.size = this.items.push(item);
    },
    process: function () {
        var i = 0;
        while (i < this.size) {
            this.items[i].findSteps();
            i++;
        }
    }
};

/* Square */
function Square(x, y) {
    this.x = x;
    this.y = y;
    var obj = document.createElement('div');
    obj.className = 'square square-col' + (x+1) + ' square-row' + (y+1);
    this.obj = Class('grid').appendChild(obj);
    this.obj.onclick = processEvent(this, 'click');
    this.ball = null;
}

Square.prototype = {
    createBall: function (color, state) {
        this.ball = new Ball(color, state);
        this.ball.parent = this;
        this.obj.appendChild(this.ball.obj);
        animation.items.push(this.ball);
    },
    deleteBall: function () {
        if (this.ball) {
            this.obj.removeChild(this.ball.obj);
            this.ball = null;
        }
        if (this == linesGrid.selected) {
            linesGrid.unselect();
        }
    },
    click: function () {
        if (this.ball && this.ball.state == 7) {
            this.select();
        }
        if (!this.ball && !animation.disableClick && linesGrid.selected && this.step) {
            this.invite();
        }
    },
    select: function () {
        linesGrid.reset();
        this.step = 1;
        pathfinder.add(this);
        pathfinder.process();
        linesGrid.unselect();
        linesGrid.selected = this;
        classNameOf(this.obj).add('selected');
    },
    invite: function () {
        var clone = linesGrid.selected.ball;
        this.createBall(clone.color, 0 - this.step);
        clone.aim = 0;
        animation.items.push(clone, this.ball);
        var last = this.from;
        while (last.step > 1) {
            last.createBall(clone.color, 7 + last.step);
            last.ball.aim = 0;
            animation.items.push(last.ball);
            last = last.from;
        }
        linesGrid.makeTurn = true;
        linesGrid.checkSquares.push(this);
        linesGrid.unselect();
        animation.onfinish = 'linesGrid.checkLines()';
        animation.start();
    },
    findSteps: function () {
        this.checkStep(this.x - 1, this.y);
        this.checkStep(this.x + 1, this.y);
        this.checkStep(this.x, this.y - 1);
        this.checkStep(this.x, this.y + 1);
    },
    checkStep: function (x, y) {
        var column = linesGrid.squares[x];
        if (!column) return false;
        var item = column[y];
        var value = this.step + 1;
        if (item && !item.ball && (!item.step || item.step > value)) {
            item.step = value;
            item.from = this;
            pathfinder.add(item);
        }
    },
    findSame: function () {
        var sameMax = new Line(this);
        var sameDiagonalDown = new Line(this);
        sameDiagonalDown.addLine(-1, -1);
        sameDiagonalDown.addLine(1, 1);
        sameMax.replace(sameDiagonalDown.items);
        var sameDiagonalUp = new Line(this);
        sameDiagonalUp.addLine(-1, 1);
        sameDiagonalUp.addLine(1, -1);
        sameMax.replace(sameDiagonalUp.items);
        var sameVertical = new Line(this);
        sameVertical.addLine(0, -1);
        sameVertical.addLine(0, 1);
        sameMax.replace(sameVertical.items);
        var sameHorizontal = new Line(this);
        sameHorizontal.addLine(-1, 0);
        sameHorizontal.addLine(1, 0);
        sameMax.replace(sameHorizontal.items);
        var directCross = false;
        if (sameHorizontal.items.length > 2) {
            sameMax.replace(this.findCross(-1, 0, 0));
            sameMax.replace(this.findCross(1, 0, 0));
            directCross = true;
        }
        if (sameVertical.items.length > 2) {
            sameMax.replace(this.findCross(0, -1, 0));
            sameMax.replace(this.findCross(0, 1, 0));
            directCross = true
        }
        if (directCross) {
            sameMax.replace(this.findCross(0, 0, 0));
        }
        var diagonslCross = false;
        if (sameDiagonalDown.items.length > 2) {
            sameMax.replace(this.findCross(-1, -1, 1));
            sameMax.replace(this.findCross(1, 1, 1));
            diagonslCross = true;
        }
        if (sameDiagonalUp.items.length > 2) {
            sameMax.replace(this.findCross(-1, 1, 1));
            sameMax.replace(this.findCross(1, -1, 1));
            diagonslCross = true
        }
        if (diagonslCross) {
            sameMax.replace(this.findCross(0, 0, 1));
        }
        return sameMax;
    },
    findCross: function (dx, dy, dd) {
        var cross = new Line(this);
        var xc = this.x + dx;
        var yc = this.y + dy;
        cross.items = [];
        cross.add(xc, yc);
        if (cross.items.length) {
            cross.add(xc + 1, yc + dd);
            cross.add(xc - 1, yc - dd);
            cross.add(xc + dd, yc - 1);
            cross.add(xc - dd, yc + 1);
        }
        return cross.items;
    }
};

function Line(obj) {
    this.color = obj.ball.color;
    this.x = obj.x;
    this.y = obj.y;
    this.items = [];
    this.items.push(obj.ball);
}

Line.prototype = {
    addLine: function (dx, dy) {
        for (var i = 1, result = true; result; i++) {
            result = this.add(this.x + i * dx, this.y + i * dy);
        }
    },
    add: function (x, y) {
        var column = linesGrid.squares[x];
        if (!column) return false;
        var item = column[y];
        if (item && item.ball && item.ball.state == 7 && item.ball.color == this.color) {
            this.items.push(item.ball);
            return true;
        } else return false;
    },
    fire: function () {
        for (var i = 0, lim = this.items.length; i < lim; i++) {
            var ball = this.items[i];
            ball.aim = 0;
            animation.items.push(ball);
        }
        Score.current += this.items.length * 2;
        animation.items.push(Score);
        linesGrid.makeTurn = false;
        animation.onfinish = 'linesGrid.checkLines()';
        animation.start();
    },
    replace: function (items) {
        if (items.length > this.items.length) {
            this.items = items;
        }
    }
};

/* Ball */

function Ball(color, state) {
    this.color = color;
    this.obj = document.createElement('div');
    this.obj.className = 'ball ball-responsive ball-' + color;
    this.state = state || 0;
    this.active = (this.state < 8);
    this.aim = this.active ? 7 : 0;
};

Ball.prototype = {
    show: function () {
        var y = this.state;
        if (y > 0 && y < 8) {
            if (!this.active) y = 1;
            this.obj.style.backgroundPosition = '0 ' + (y - 7) * this.obj.offsetWidth* 1.1 + 'px';
            this.obj.style.visibility = 'visible';
        } else {
            this.obj.style.visibility = 'hidden';
        }
    },
    animate: function () {
        if (this.state > this.aim) this.state--;
        if (this.state < this.aim) this.state++;
        if (this.state == 0 && this.aim == 0) {
            this.parent.deleteBall();
            return false;
        } else {
            this.show();
            return (this.state != this.aim);
        }
    }
};

/* Scores */
var Score = {
    init: function () {
        this.value = 0;
        this.current = 0;
        this.obj = Class('score');
        this.obj.innerHTML = this.value;
    },
    animate: function () {
        if (this.current) {
            this.current--;
            this.value++;
            this.obj.innerHTML = this.value;
        }
        if (!this.current) {
            highscore.show();
        }
        return this.current;
    }
};

var highscore = {
    active: false,
    init: function () {
        this.obj = Class('highscore');
        var record = Cookies.get('highscore');
        if (record) {
            this.value = parseInt(record);
            this.show();
        }
    },
    show: function () {
        if (this.value) {
            if (Score.value <= this.value) {
                this.obj.innerHTML = this.value;
            }
            if (Score.value > this.value) {
                this.obj.innerHTML = Score.value;
                this.save();
            }
        } else {
            this.save();
        }
    },
    save: function () {
        Cookies.set('highscore', Score.value);
    }
};

/* Animation */
var animation = {
    items: [],
    active: false,
    timer: null,
    endTimer: null,
    disableClick: false,
    start: function () {
        clearTimeout(this.endTimer);
        this.disableClick = true;
        if (!this.active) {
            this.apply();
        }
    },
    end: function () {
        clearTimeout(this.endTimer);
        this.disableClick = false;
    },
    apply: function () {
        clearTimeout(this.timer);
        this.active = false;
        for (var i = 0, lim = this.items.length; i < lim; i++) {
            var item = this.items.shift(0);
            if (item.animate()) {
                this.items.push(item);
            }
        }
        if (this.items.length) {
            this.active = true;
            this.timer = setTimeout('animation.apply()', 50);
        } else if (this.onfinish) {
            this.endTimer = setTimeout('animation.end()', 300);
            setTimeout(this.onfinish, 250);
            this.onfinish = null;
        } else {
            this.end();
        }
    }
};
(function ($, _) {
    $(document).ready(function () {
        linesGrid.init();
    });

    $('.js-next-turn').click(function () {
        linesGrid.turn()
    });

    $('.js-new-game').click(function () {
        linesGrid.init()
    });

    $('.js-toggles').click(function() {
        $(this).find('.js-toggle').each(function(){
            $(this).toggleClass('js-hidden');
        });
    });
})(jQuery, _);
